---
description: Validar PR antes del merge verificando cumplimiento de requerimientos y contexto
allowed-tools: [Read, Bash, Glob, TodoWrite]
---

# Validate PR

Validar pull request antes del merge: **$ARGUMENTS**

## Proceso:

### 1. Recolecci√≥n de Informaci√≥n del PR

**Obtener datos b√°sicos del PR:**
```bash
PR_NUMBER="$ARGUMENTS"

if [ -z "$PR_NUMBER" ]; then
  echo "‚ùå Error: Debe especificar el n√∫mero del PR"
  echo "Uso: /validate-pr {pr-number}"
  exit 1
fi

echo "üîç Analizando PR #$PR_NUMBER..."
echo ""

# Verificar que el PR existe
if ! gh pr view $PR_NUMBER >/dev/null 2>&1; then
  echo "‚ùå Error: PR #$PR_NUMBER no encontrado"
  exit 1
fi

# Obtener informaci√≥n completa del PR
PR_INFO=$(gh pr view $PR_NUMBER --json title,body,files,additions,deletions,author,state,reviewRequests,reviews)
PR_TITLE=$(echo "$PR_INFO" | jq -r '.title')
PR_BODY=$(echo "$PR_INFO" | jq -r '.body')
PR_STATE=$(echo "$PR_INFO" | jq -r '.state')
PR_AUTHOR=$(echo "$PR_INFO" | jq -r '.author.login')
CHANGED_FILES=$(echo "$PR_INFO" | jq -r '.files[].path' | tr '\n' ' ')
ADDITIONS=$(echo "$PR_INFO" | jq -r '.additions')
DELETIONS=$(echo "$PR_INFO" | jq -r '.deletions')

echo "üìä Informaci√≥n del PR:"
echo "- T√≠tulo: $PR_TITLE"
echo "- Estado: $PR_STATE"
echo "- Autor: $PR_AUTHOR"
echo "- Cambios: +$ADDITIONS -$DELETIONS"
echo "- Archivos modificados: $(echo "$PR_INFO" | jq -r '.files | length')"
echo ""
```

### 2. Identificar Issues Relacionados

**Extraer referencias de issues (texto + detecci√≥n autom√°tica GitHub):**
```bash
# Buscar referencias a issues en el cuerpo del PR
RELATED_ISSUES=$(echo "$PR_BODY" | grep -oE "#[0-9]+" | sort -u | tr '\n' ' ')

# Verificar detecci√≥n autom√°tica de GitHub usando GraphQL
# Obtener owner y repo din√°micamente  
REPO_OWNER=$(gh repo view --json owner --jq '.owner.login')
REPO_NAME=$(gh repo view --json name --jq '.name')

AUTO_CLOSING_ISSUES=$(gh api graphql --field query='
{
  repository(owner: "'$REPO_OWNER'", name: "'$REPO_NAME'") {
    pullRequest(number: '$PR_NUMBER') {
      closingIssuesReferences(first: 10) {
        nodes {
          number
          title
        }
      }
    }
  }
}' --jq '.data.repository.pullRequest.closingIssuesReferences.nodes[]')

if [ -z "$RELATED_ISSUES" ] && [ -z "$AUTO_CLOSING_ISSUES" ]; then
  echo "‚ö†Ô∏è  No se encontraron referencias a issues en el PR"
  echo "   Recomendaci√≥n: Agregar referencias como 'Closes #123'"
  echo ""
elif [ ! -z "$AUTO_CLOSING_ISSUES" ]; then
  echo "üéØ Issues que GitHub cerrar√° autom√°ticamente:"
  echo "$AUTO_CLOSING_ISSUES" | while read -r issue; do
    ISSUE_NUM=$(echo "$issue" | jq -r '.number')
    ISSUE_TITLE=$(echo "$issue" | jq -r '.title')
    echo "   ‚úÖ #$ISSUE_NUM: $ISSUE_TITLE"
    RELATED_ISSUES="$RELATED_ISSUES #$ISSUE_NUM"
  done
  echo ""
else
  echo "üéØ Issues relacionados: $RELATED_ISSUES"
  echo ""
fi

if [ ! -z "$RELATED_ISSUES" ] || [ ! -z "$AUTO_CLOSING_ISSUES" ]; then
  # Usar issues detectados autom√°ticamente si no hay expl√≠citos
  if [ -z "$RELATED_ISSUES" ]; then
    RELATED_ISSUES=$(echo "$AUTO_CLOSING_ISSUES" | jq -r '.number' | sed 's/^/#/' | tr '\n' ' ')
  fi
  
  # Para cada issue, obtener informaci√≥n
  for ISSUE_REF in $RELATED_ISSUES; do
    ISSUE_NUM=$(echo $ISSUE_REF | sed 's/#//')
    echo "üìã Analizando Issue $ISSUE_REF:"
    
    if gh issue view $ISSUE_NUM >/dev/null 2>&1; then
      ISSUE_INFO=$(gh issue view $ISSUE_NUM --json title,body,state,labels,milestone,comments)
      ISSUE_TITLE=$(echo "$ISSUE_INFO" | jq -r '.title')
      ISSUE_STATE=$(echo "$ISSUE_INFO" | jq -r '.state')
      ISSUE_LABELS=$(echo "$ISSUE_INFO" | jq -r '.labels[].name' | tr '\n' ',' | sed 's/,$//')
      
      echo "  - T√≠tulo: $ISSUE_TITLE"
      echo "  - Estado: $ISSUE_STATE"
      echo "  - Labels: $ISSUE_LABELS"
      
      # Analizar comentarios del issue para contexto adicional
      COMMENTS_COUNT=$(echo "$ISSUE_INFO" | jq -r '.comments | length')
      echo "  - Comentarios: $COMMENTS_COUNT"
      
      if [ $COMMENTS_COUNT -gt 0 ]; then
        echo "  üìù Analizando comentarios del issue..."
        
        # Extraer informaci√≥n clave de los comentarios
        COMMENTS_TEXT=$(echo "$ISSUE_INFO" | jq -r '.comments[].body' | tr '\n' ' ')
        
        # Buscar testing reportado en comentarios
        if echo "$COMMENTS_TEXT" | grep -qi -E "(test|probado|funciona|working|deployed|desplegado|endpoint|api.*ok|‚úÖ)"; then
          echo "     ‚úÖ Testing/validaci√≥n reportado en comentarios"
          TESTING_REPORTED=true
        else
          echo "     ‚ÑπÔ∏è  No se report√≥ testing en comentarios"
          TESTING_REPORTED=false
        fi
        
        # Buscar URLs/endpoints mencionados
        ENDPOINTS_MENTIONED=$(echo "$COMMENTS_TEXT" | grep -oE "https?://[a-zA-Z0-9.-]+(/[a-zA-Z0-9./?=&-]*)?" | head -3 | tr '\n' ' ')
        if [ ! -z "$ENDPOINTS_MENTIONED" ]; then
          echo "     üîó URLs/endpoints mencionados: $ENDPOINTS_MENTIONED"
        fi
        
        # Buscar cambios/decisiones importantes en comentarios
        if echo "$COMMENTS_TEXT" | grep -qi -E "(cambio|modificado|actualizado|decision|acordado|implemented|completado)"; then
          echo "     üìã Decisiones/cambios importantes documentados en comentarios"
          DECISIONS_DOCUMENTED=true
        else
          DECISIONS_DOCUMENTED=false
        fi
        
        # Buscar problemas/blockers resueltos
        if echo "$COMMENTS_TEXT" | grep -qi -E "(problema|issue|blocker|error.*resuelto|fixed|solucionado)"; then
          echo "     üîß Problemas/blockers resueltos documentados"
          BLOCKERS_RESOLVED=true
        else
          BLOCKERS_RESOLVED=false
        fi
        
        # Extraer requirements adicionales de comentarios
        ADDITIONAL_REQUIREMENTS=""
        if echo "$COMMENTS_TEXT" | grep -qi -E "(tambi√©n.*necesita|adem√°s.*debe|falta.*agregar|missing|pendiente)"; then
          echo "     ‚ö†Ô∏è  Posibles requirements adicionales mencionados en comentarios"
          ADDITIONAL_REQUIREMENTS="detected"
        fi
        
      else
        echo "     ‚ÑπÔ∏è  Sin comentarios adicionales"
        TESTING_REPORTED=false
        DECISIONS_DOCUMENTED=false
        BLOCKERS_RESOLVED=false
      fi
      
      # Guardar informaci√≥n del issue para an√°lisis posterior
      echo "$ISSUE_INFO" > .claude/temp/issue-$ISSUE_NUM-info.json
      
      # Guardar contexto de comentarios para validaci√≥n posterior
      cat > .claude/temp/issue-$ISSUE_NUM-context.json << EOF
{
  "testing_reported": $TESTING_REPORTED,
  "decisions_documented": $DECISIONS_DOCUMENTED,
  "blockers_resolved": $BLOCKERS_RESOLVED,
  "additional_requirements": "$ADDITIONAL_REQUIREMENTS",
  "endpoints_mentioned": "$ENDPOINTS_MENTIONED",
  "comments_count": $COMMENTS_COUNT
}
EOF
    else
      echo "  ‚ùå Issue #$ISSUE_NUM no encontrado"
    fi
    echo ""
  done
fi
```

### 3. Revisi√≥n de Documentaci√≥n del Proyecto

**Buscar y analizar gu√≠as relevantes:**
```bash
echo "üìö Revisando documentaci√≥n del proyecto..."

# Buscar gu√≠as de contribuci√≥n
CONTRIB_GUIDE=$(find . doc/ docs/ -maxdepth 3 -name "*.md" | xargs grep -l -i -E "(contribuci|contribution|pr|pull.*request)" 2>/dev/null | head -1)

if [ ! -z "$CONTRIB_GUIDE" ]; then
  echo "‚úÖ Gu√≠a de contribuciones encontrada: $CONTRIB_GUIDE"
else
  echo "‚ö†Ô∏è  No se encontr√≥ gu√≠a de contribuciones espec√≠fica"
fi

# Leer CLAUDE.md para contexto del proyecto
if [ -f "CLAUDE.md" ]; then
  echo "‚úÖ Documentaci√≥n del proyecto: CLAUDE.md"
  # Extraer tecnolog√≠as del stack
  TECH_STACK=$(grep -A 20 "Technology Stack\|Tech Stack" CLAUDE.md | grep -E "^\- \*\*|^\* \*\*" | head -10)
  if [ ! -z "$TECH_STACK" ]; then
    echo "üõ†Ô∏è  Stack tecnol√≥gico identificado"
  fi
else
  echo "‚ö†Ô∏è  CLAUDE.md no encontrado"
fi

# Buscar documentaci√≥n de arquitectura
ARCH_DOCS=$(find . doc/ docs/ -name "*.md" | xargs grep -l -i "arquitectura\|architecture" 2>/dev/null | head -3)
if [ ! -z "$ARCH_DOCS" ]; then
  echo "‚úÖ Documentaci√≥n de arquitectura encontrada"
fi

echo ""
```

### 4. An√°lisis de Cumplimiento de Requerimientos

**Validar cumplimiento b√°sico:**
```bash
echo "üîç An√°lisis de Cumplimiento:"
echo ""

# Inicializar contadores
VALIDATIONS_PASSED=0
VALIDATIONS_TOTAL=0
OBSERVATIONS=()
RECOMMENDATIONS=()

# Validaci√≥n 1: Estructura del PR
echo "1Ô∏è‚É£ Estructura del PR:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

# Verificar t√≠tulo sigue convenciones
if echo "$PR_TITLE" | grep -qE "^(feat|fix|docs|refactor|test|chore|style|perf|ci)(\(.+\))?: "; then
  echo "   ‚úÖ T√≠tulo sigue convenciones (feat/fix/docs/etc.)"
  VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
else
  echo "   ‚ùå T√≠tulo no sigue convenciones de commit"
  RECOMMENDATIONS+=("Usar formato: 'feat: descripci√≥n' o 'fix: descripci√≥n'")
fi

# Verificar descripci√≥n tiene contenido
if [ ${#PR_BODY} -gt 50 ]; then
  echo "   ‚úÖ Descripci√≥n detallada presente"
else
  echo "   ‚ö†Ô∏è  Descripci√≥n muy breve"
  RECOMMENDATIONS+=("Agregar m√°s detalles en la descripci√≥n del PR")
fi

# Validaci√≥n 2: Alineaci√≥n con Issues
echo ""
echo "2Ô∏è‚É£ Alineaci√≥n con Issues:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

if [ ! -z "$RELATED_ISSUES" ] || [ ! -z "$AUTO_CLOSING_ISSUES" ]; then
  echo "   ‚úÖ Issues referenciados correctamente"
  VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
  
  # Verificar si usa "Closes" expl√≠cito o detecci√≥n autom√°tica
  if echo "$PR_BODY" | grep -qE "(Closes|Fixes|Resolves) #[0-9]+"; then
    echo "   ‚úÖ Configurado para auto-cerrar issues (referencia expl√≠cita)"
  elif [ ! -z "$AUTO_CLOSING_ISSUES" ]; then
    echo "   ‚úÖ Configurado para auto-cerrar issues (detecci√≥n autom√°tica GitHub)"
  else
    echo "   ‚ö†Ô∏è  No configurado para auto-cerrar issues"
    RECOMMENDATIONS+=("Usar 'Closes #123' para auto-cerrar issues al mergear")
  fi
else
  echo "   ‚ùå No hay referencias a issues"
  RECOMMENDATIONS+=("Agregar referencias a issues relacionados con 'Closes #123'")
fi

# Validaci√≥n 3: Coherencia de Archivos
echo ""
echo "3Ô∏è‚É£ Coherencia de Archivos Modificados:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

# Analizar tipos de archivos modificados
INFRASTRUCTURE_FILES=$(echo "$CHANGED_FILES" | grep -E "(iac/|infrastructure/|\.yaml$|\.yml$|template\.)" | wc -w)
BACKEND_FILES=$(echo "$CHANGED_FILES" | grep -E "\.(js|ts|py|java|go|rs)$" | wc -w)
FRONTEND_FILES=$(echo "$CHANGED_FILES" | grep -E "\.(jsx|tsx|vue|svelte|html|css|scss)$" | wc -w)
DOC_FILES=$(echo "$CHANGED_FILES" | grep -E "\.md$" | wc -w)
CONFIG_FILES=$(echo "$CHANGED_FILES" | grep -E "\.(json|toml|env|config)$" | wc -w)

echo "   üìÅ Tipos de archivos modificados:"
[ $INFRASTRUCTURE_FILES -gt 0 ] && echo "      - Infraestructura: $INFRASTRUCTURE_FILES archivos"
[ $BACKEND_FILES -gt 0 ] && echo "      - Backend: $BACKEND_FILES archivos"
[ $FRONTEND_FILES -gt 0 ] && echo "      - Frontend: $FRONTEND_FILES archivos"
[ $DOC_FILES -gt 0 ] && echo "      - Documentaci√≥n: $DOC_FILES archivos"
[ $CONFIG_FILES -gt 0 ] && echo "      - Configuraci√≥n: $CONFIG_FILES archivos"

# Verificar coherencia con issue si existe
if [ ! -z "$RELATED_ISSUES" ]; then
  # An√°lisis b√°sico de coherencia
  ISSUE_NUM=$(echo $RELATED_ISSUES | cut -d' ' -f1 | sed 's/#//')
  if [ -f ".claude/temp/issue-$ISSUE_NUM-info.json" ]; then
    ISSUE_LABELS=$(jq -r '.labels[].name' .claude/temp/issue-$ISSUE_NUM-info.json | tr '\n' ' ')
    
    # Verificar coherencia entre labels y archivos
    COHERENT=true
    if echo "$ISSUE_LABELS" | grep -q "infrastructure" && [ $INFRASTRUCTURE_FILES -eq 0 ]; then
      COHERENT=false
      OBSERVATIONS+=("Issue marcado como 'infrastructure' pero no se modificaron archivos de infraestructura")
    fi
    if echo "$ISSUE_LABELS" | grep -q "backend" && [ $BACKEND_FILES -eq 0 ]; then
      COHERENT=false
      OBSERVATIONS+=("Issue marcado como 'backend' pero no se modificaron archivos de backend")
    fi
    if echo "$ISSUE_LABELS" | grep -q "frontend" && [ $FRONTEND_FILES -eq 0 ]; then
      COHERENT=false
      OBSERVATIONS+=("Issue marcado como 'frontend' pero no se modificaron archivos de frontend")
    fi
    
    if $COHERENT; then
      echo "   ‚úÖ Archivos coherentes con tipo de issue"
      VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    else
      echo "   ‚ö†Ô∏è  Posible desalineaci√≥n entre issue y archivos modificados"
    fi
  else
    echo "   ‚úÖ Archivos modificados parecen coherentes"
    VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
  fi
else
  echo "   ‚ö†Ô∏è  Sin issue de referencia para validar coherencia"
fi

# Validaci√≥n 4: Documentaci√≥n Duplicada (Solo si hay archivos .md)
echo ""
echo "4Ô∏è‚É£ Validaci√≥n de Documentaci√≥n Duplicada:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

if [ $DOC_FILES -gt 0 ]; then
  echo "   üìã Detectados $DOC_FILES archivos de documentaci√≥n - Verificando duplicaci√≥n..."
  
  # Obtener archivos .md modificados en el PR
  MODIFIED_DOCS=$(echo "$CHANGED_FILES" | grep "\.md$")
  
  if [ ! -z "$MODIFIED_DOCS" ]; then
    DUPLICATIONS_FOUND=false
    
    echo "$MODIFIED_DOCS" | while IFS= read -r DOC_FILE; do
      if [ -f "$DOC_FILE" ]; then
        echo "   üîç Analizando: $DOC_FILE"
        
        # Extraer t√≠tulos/headers del documento modificado
        NEW_HEADERS=$(grep -E "^#{1,3} " "$DOC_FILE" 2>/dev/null | head -10)
        
        if [ ! -z "$NEW_HEADERS" ]; then
          # Buscar headers similares en otros documentos
          echo "$NEW_HEADERS" | while IFS= read -r HEADER; do
            CLEAN_HEADER=$(echo "$HEADER" | sed 's/^#*[[:space:]]*//' | tr '[:upper:]' '[:lower:]')
            
            if [ ${#CLEAN_HEADER} -gt 10 ]; then
              # Buscar en otros archivos .md (excluyendo el actual)
              SIMILAR_DOCS=$(find . -name "*.md" -not -path "./$DOC_FILE" -not -path "./.git/*" | \
                           xargs grep -l -i "$CLEAN_HEADER" 2>/dev/null | head -3)
              
              if [ ! -z "$SIMILAR_DOCS" ]; then
                echo "      ‚ö†Ô∏è  Posible duplicaci√≥n: '$CLEAN_HEADER'"
                echo "         Tambi√©n en: $(echo "$SIMILAR_DOCS" | tr '\n' ' ')"
                DUPLICATIONS_FOUND=true
              fi
            fi
          done
        fi
        
        # Verificar comandos duplicados (l√≠neas que empiezan con comandos comunes)
        NEW_COMMANDS=$(grep -E "^[[:space:]]*(\`\`\`|npm |git |curl |docker |kubectl )" "$DOC_FILE" 2>/dev/null | head -5)
        
        if [ ! -z "$NEW_COMMANDS" ]; then
          echo "$NEW_COMMANDS" | while IFS= read -r COMMAND; do
            CLEAN_COMMAND=$(echo "$COMMAND" | sed 's/^[[:space:]]*//' | cut -c1-50)
            
            if [ ${#CLEAN_COMMAND} -gt 15 ]; then
              # Buscar comando similar en otros documentos
              SIMILAR_COMMAND_DOCS=$(find . -name "*.md" -not -path "./$DOC_FILE" -not -path "./.git/*" | \
                                   xargs grep -l -F "$CLEAN_COMMAND" 2>/dev/null | head -2)
              
              if [ ! -z "$SIMILAR_COMMAND_DOCS" ]; then
                echo "      ‚ö†Ô∏è  Comando posiblemente duplicado: '$CLEAN_COMMAND'"
                echo "         Tambi√©n en: $(echo "$SIMILAR_COMMAND_DOCS" | tr '\n' ' ')"
              fi
            fi
          done
        fi
      fi
    done
    
    if [ "$DUPLICATIONS_FOUND" = false ]; then
      echo "   ‚úÖ No se detectaron duplicaciones obvias en documentaci√≥n"
      VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    else
      echo "   ‚ö†Ô∏è  Se detectaron posibles duplicaciones - revisar manualmente"
      RECOMMENDATIONS+=("Revisar si la nueva documentaci√≥n duplica contenido existente")
      RECOMMENDATIONS+=("Considerar actualizar documentos existentes en lugar de crear nuevos")
      RECOMMENDATIONS+=("Verificar que comandos documentados no est√©n ya explicados en otro lugar")
    fi
  else
    echo "   ‚úÖ Sin archivos .md modificados detectados"
    VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
  fi
else
  echo "   ‚úÖ Sin archivos de documentaci√≥n en este PR"
  VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
fi

# Validaci√≥n 5: Contexto de Comentarios del Issue
echo ""
echo "5Ô∏è‚É£ Contexto de Comentarios del Issue:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

if [ ! -z "$RELATED_ISSUES" ]; then
  MAIN_ISSUE_NUM=$(echo $RELATED_ISSUES | cut -d' ' -f1 | sed 's/#//')
  
  if [ -f ".claude/temp/issue-$MAIN_ISSUE_NUM-context.json" ]; then
    # Leer contexto de comentarios
    TESTING_REPORTED=$(jq -r '.testing_reported' .claude/temp/issue-$MAIN_ISSUE_NUM-context.json)
    DECISIONS_DOCUMENTED=$(jq -r '.decisions_documented' .claude/temp/issue-$MAIN_ISSUE_NUM-context.json)
    BLOCKERS_RESOLVED=$(jq -r '.blockers_resolved' .claude/temp/issue-$MAIN_ISSUE_NUM-context.json)
    ADDITIONAL_REQUIREMENTS=$(jq -r '.additional_requirements' .claude/temp/issue-$MAIN_ISSUE_NUM-context.json)
    ENDPOINTS_MENTIONED=$(jq -r '.endpoints_mentioned' .claude/temp/issue-$MAIN_ISSUE_NUM-context.json)
    
    CONTEXT_SCORE=0
    CONTEXT_TOTAL=3
    
    # Evaluar si el PR refleja lo discutido en comentarios
    if [ "$TESTING_REPORTED" = "true" ]; then
      echo "   ‚úÖ Testing fue reportado en comentarios del issue"
      CONTEXT_SCORE=$((CONTEXT_SCORE + 1))
      
      # Verificar si el PR menciona este testing
      if echo "$PR_BODY" | grep -qi -E "(test|probado|validado|verificado)"; then
        echo "   ‚úÖ PR menciona testing/validaci√≥n realizada"
      else
        echo "   ‚ö†Ô∏è  PR no menciona testing reportado en issue"
        RECOMMENDATIONS+=("Incluir informaci√≥n sobre testing realizado en descripci√≥n del PR")
      fi
    else
      echo "   ‚ÑπÔ∏è  No se report√≥ testing espec√≠fico en comentarios"
      CONTEXT_SCORE=$((CONTEXT_SCORE + 1))
    fi
    
    if [ "$DECISIONS_DOCUMENTED" = "true" ]; then
      echo "   ‚úÖ Decisiones importantes documentadas en comentarios"
      CONTEXT_SCORE=$((CONTEXT_SCORE + 1))
    else
      echo "   ‚ÑπÔ∏è  Sin decisiones importantes en comentarios"
      CONTEXT_SCORE=$((CONTEXT_SCORE + 1))
    fi
    
    if [ "$ADDITIONAL_REQUIREMENTS" = "detected" ]; then
      echo "   ‚ö†Ô∏è  Se detectaron requirements adicionales en comentarios"
      echo "       Verificar que el PR los incluya"
      RECOMMENDATIONS+=("Revisar comentarios del issue para requirements adicionales mencionados")
    else
      echo "   ‚úÖ Sin requirements adicionales detectados"
      CONTEXT_SCORE=$((CONTEXT_SCORE + 1))
    fi
    
    # Verificar endpoints mencionados
    if [ "$ENDPOINTS_MENTIONED" != "null" ] && [ ! -z "$ENDPOINTS_MENTIONED" ]; then
      echo "   üîó Endpoints mencionados en issue: $ENDPOINTS_MENTIONED"
      OBSERVATIONS+=("Issue menciona endpoints espec√≠ficos - verificar que sean los correctos")
    fi
    
    if [ $CONTEXT_SCORE -eq $CONTEXT_TOTAL ]; then
      echo "   ‚úÖ PR alineado con contexto de comentarios del issue"
      VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    else
      echo "   ‚ö†Ô∏è  Revisar alineaci√≥n con comentarios del issue ($CONTEXT_SCORE/$CONTEXT_TOTAL)"
    fi
  else
    echo "   ‚ÑπÔ∏è  Sin contexto de comentarios disponible"
    VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
  fi
else
  echo "   ‚ö†Ô∏è  Sin issues relacionados para analizar contexto"
fi

# Validaci√≥n 6: Convenciones del Proyecto
echo ""
echo "6Ô∏è‚É£ Convenciones del Proyecto:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

# Verificar estructura de carpetas
FOLLOWS_STRUCTURE=true
if echo "$CHANGED_FILES" | grep -q "iac/" && [ -d "iac/" ]; then
  echo "   ‚úÖ Sigue estructura de carpetas (iac/)"
elif echo "$CHANGED_FILES" | grep -q "doc/" && [ -d "doc/" ]; then
  echo "   ‚úÖ Sigue estructura de carpetas (doc/)"
elif echo "$CHANGED_FILES" | grep -q "apps/" && [ -d "apps/" ]; then
  echo "   ‚úÖ Sigue estructura de carpetas (apps/)"
else
  echo "   ‚úÖ Estructura de carpetas respetada"
fi

VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))

# Validaci√≥n 7: Cumplimiento de Gu√≠as de Dise√±o/UI (Solo si hay cambios frontend)
echo ""
echo "7Ô∏è‚É£ Cumplimiento de Gu√≠as de Dise√±o/UI:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

if [ $FRONTEND_FILES -gt 0 ]; then
  echo "   üé® Detectados cambios frontend - Verificando cumplimiento de gu√≠as de dise√±o..."
  
  # Buscar documentaci√≥n de design system/gu√≠as de UI
  DESIGN_DOCS=$(find . doc/ docs/ -name "*.md" | xargs grep -l -i -E "(design.*system|style.*guide|ui.*guide|component.*guide|frontend.*guide)" 2>/dev/null | head -3)
  
  if [ ! -z "$DESIGN_DOCS" ]; then
    echo "   üìã Gu√≠as de dise√±o encontradas:"
    echo "$DESIGN_DOCS" | while IFS= read -r DOC; do
      echo "      - $DOC"
    done
    echo ""
    echo "   üîç Verificando cumplimiento de gu√≠as..."
    
    DESIGN_ISSUES=()
    
    # Analizar archivos frontend modificados
    COMPONENT_FILES=$(echo "$CHANGED_FILES" | grep -E "\.(tsx|jsx|ts|js|css|scss|less)$")
    if [ ! -z "$COMPONENT_FILES" ]; then
      echo "   üìù Archivos frontend a revisar:"
      echo "$COMPONENT_FILES" | while IFS= read -r FILE; do
        echo "      - $FILE"
      done
      echo ""
      
      # Verificaciones gen√©ricas de buenas pr√°cticas
      echo "   ‚öôÔ∏è  Verificaciones autom√°ticas:"
      
      echo "$COMPONENT_FILES" | while IFS= read -r FILE; do
        if [ -f "$FILE" ]; then
          FILE_ISSUES=()
          
          # Verificar colores hardcoded
          if grep -q -E "#[0-9a-fA-F]{3,6}|rgb\(|rgba\(" "$FILE" 2>/dev/null; then
            FILE_ISSUES+=("Colores hardcoded encontrados - considerar usar design tokens")
          fi
          
          # Verificar definiciones de fuentes inline
          if grep -q -E "font-family.*:|fontFamily.*:" "$FILE" 2>/dev/null; then
            FILE_ISSUES+=("Definiciones de fuentes inline - verificar si siguen gu√≠as corporativas")
          fi
          
          # Verificar estilos inline extensos
          INLINE_STYLES=$(grep -c "style=" "$FILE" 2>/dev/null || echo "0")
          if [ "$INLINE_STYLES" -gt 5 ]; then
            FILE_ISSUES+=("Muchos estilos inline ($INLINE_STYLES) - considerar CSS externo o design tokens")
          fi
          
          # Mostrar issues encontrados
          if [ ${#FILE_ISSUES[@]} -gt 0 ]; then
            echo "      ‚ö†Ô∏è  $FILE:"
            for issue in "${FILE_ISSUES[@]}"; do
              echo "         - $issue"
              DESIGN_ISSUES+=("$FILE: $issue")
            done
          else
            echo "      ‚úÖ $FILE: Sin issues obvios detectados"
          fi
        fi
      done
    fi
    
    # Verificar ubicaci√≥n de componentes (si aplica estructura de apps)
    NEW_COMPONENTS=$(echo "$CHANGED_FILES" | grep -E "/components/.*\.(tsx|jsx)$")
    if [ ! -z "$NEW_COMPONENTS" ] && [ -d "apps" ]; then
      echo ""
      echo "   üìÇ Verificando ubicaci√≥n de componentes:"
      SHARED_COMPONENTS=$(echo "$NEW_COMPONENTS" | grep "/shared/")
      APP_SPECIFIC=$(echo "$NEW_COMPONENTS" | grep -v "/shared/")
      
      if [ ! -z "$APP_SPECIFIC" ]; then
        echo "      ‚ÑπÔ∏è  Componentes en apps espec√≠ficas:"
        echo "$APP_SPECIFIC" | while IFS= read -r COMP; do
          echo "         - $COMP"
        done
        DESIGN_ISSUES+=("Evaluar si componentes nuevos podr√≠an ser reutilizables en /shared")
      fi
      
      if [ ! -z "$SHARED_COMPONENTS" ]; then
        echo "      ‚úÖ Componentes en /shared: $(echo "$SHARED_COMPONENTS" | wc -l)"
      fi
    fi
    
    # Resultado final
    if [ ${#DESIGN_ISSUES[@]} -eq 0 ]; then
      echo ""
      echo "   ‚úÖ Cambios frontend cumplen verificaciones autom√°ticas"
      VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    else
      echo ""
      echo "   ‚ö†Ô∏è  Issues detectados que requieren revisi√≥n manual:"
      OBSERVATIONS+=("DISE√ëO: Revisar cumplimiento de gu√≠as en archivos frontend modificados")
      RECOMMENDATIONS+=("Consultar gu√≠as de dise√±o encontradas: $(echo "$DESIGN_DOCS" | tr '\n' ', ' | sed 's/,$//')")
      RECOMMENDATIONS+=("Verificar manualmente que cambios frontend siguen est√°ndares del proyecto")
      RECOMMENDATIONS+=("Considerar correcciones menores o consultar con el equipo si son cambios mayores")
    fi
  else
    echo "   ‚ö†Ô∏è  No se encontraron gu√≠as de dise√±o espec√≠ficas"
    echo "   üìù Ubicaciones sugeridas para buscar gu√≠as:"
    echo "      - doc/design-system.md"
    echo "      - doc/ui-guidelines.md"
    echo "      - doc/frontend-architecture.md"
    echo "      - apps/shared/src/styles/README.md"
    OBSERVATIONS+=("Sin gu√≠as de dise√±o encontradas - revisar manualmente cumplimiento de est√°ndares")
    RECOMMENDATIONS+=("Crear o ubicar documentaci√≥n de gu√≠as de dise√±o para futuras validaciones")
  fi
else
  echo "   ‚úÖ Sin cambios frontend detectados"
  VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
fi

# Validaci√≥n 8: An√°lisis de Nuevas Dependencias
echo ""
echo "8Ô∏è‚É£ An√°lisis de Nuevas Dependencias:"
VALIDATIONS_TOTAL=$((VALIDATIONS_TOTAL + 1))

# Verificar si hay cambios en archivos de dependencias
DEPENDENCY_FILES=$(echo "$CHANGED_FILES" | grep -E "(package\.json|package-lock\.json|yarn\.lock|requirements\.txt|Pipfile|go\.mod|composer\.json|Cargo\.toml)")

if [ ! -z "$DEPENDENCY_FILES" ]; then
  echo "   üì¶ Detectados cambios en dependencias - Analizando..."
  
  # Verificar package.json si existe
  if echo "$DEPENDENCY_FILES" | grep -q "package\.json"; then
    echo "   üîç Analizando cambios en package.json..."
    
    # Obtener diff del archivo para ver qu√© se agreg√≥
    NEW_DEPS=$(gh pr diff $PR_NUMBER -- package.json | grep "^+" | grep -E "\"[^\"]+\":" | head -10)
    
    if [ ! -z "$NEW_DEPS" ]; then
      echo "   üì¶ Nuevas dependencias detectadas:"
      echo "$NEW_DEPS" | while IFS= read -r DEP; do
        # Extraer nombre del paquete
        PACKAGE_NAME=$(echo "$DEP" | grep -oE "\"[^\"]+\"" | head -1 | tr -d '"')
        if [ ! -z "$PACKAGE_NAME" ]; then
          echo "      - $PACKAGE_NAME"
          
          # Verificar si ya existe funcionalidad similar
          SIMILAR_DEPS=$(grep -r "$PACKAGE_NAME\|$(echo $PACKAGE_NAME | cut -d'-' -f1)" package.json 2>/dev/null | grep -v "^package\.json:" | head -3)
          if [ ! -z "$SIMILAR_DEPS" ]; then
            echo "         ‚ö†Ô∏è  Posible funcionalidad similar ya existente"
            OBSERVATIONS+=("DEPENDENCIA: $PACKAGE_NAME - verificar si no duplica funcionalidad existente")
          fi
          
          # Verificar si est√° en la documentaci√≥n de arquitectura
          if [ ! -z "$ARCH_DOCS" ]; then
            MENTIONED_IN_ARCH=$(echo "$ARCH_DOCS" | xargs grep -l "$PACKAGE_NAME" 2>/dev/null)
            if [ ! -z "$MENTIONED_IN_ARCH" ]; then
              echo "         ‚úÖ Mencionado en documentaci√≥n de arquitectura"
            else
              echo "         ‚ö†Ô∏è  No mencionado en documentaci√≥n de arquitectura"
              OBSERVATIONS+=("DEPENDENCIA: $PACKAGE_NAME - considerar documentar en arquitectura si es significativo")
            fi
          fi
        fi
      done
      
      # Recomendaciones generales para nuevas dependencias
      RECOMMENDATIONS+=("Validar que nuevas dependencias son realmente necesarias")
      RECOMMENDATIONS+=("Verificar que no duplican funcionalidad existente en el proyecto")
      RECOMMENDATIONS+=("Considerar el impacto en bundle size y seguridad")
      RECOMMENDATIONS+=("Documentar decisiones de nuevas dependencias si son significativas")
    else
      echo "   ‚úÖ Solo cambios menores en package.json (versiones, etc.)"
      VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
    fi
  else
    echo "   ‚úÖ Cambios en dependencias parecen rutinarios"
    VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
  fi
else
  echo "   ‚úÖ Sin cambios en dependencias detectados"
  VALIDATIONS_PASSED=$((VALIDATIONS_PASSED + 1))
fi

echo ""
```

### 5. Generaci√≥n de Reporte Final

**Crear reporte de validaci√≥n:**
```bash
echo "üìã REPORTE DE VALIDACI√ìN - PR #$PR_NUMBER"
echo "================================================="
echo ""

# Calcular porcentaje de cumplimiento
if [ $VALIDATIONS_TOTAL -gt 0 ]; then
  PERCENTAGE=$((VALIDATIONS_PASSED * 100 / VALIDATIONS_TOTAL))
else
  PERCENTAGE=0
fi

echo "üìä Resumen: $VALIDATIONS_PASSED/$VALIDATIONS_TOTAL validaciones pasaron ($PERCENTAGE%)"

if [ $PERCENTAGE -ge 80 ]; then
  echo "üéØ Estado: ‚úÖ EXCELENTE - Listo para review"
elif [ $PERCENTAGE -ge 60 ]; then
  echo "üéØ Estado: ‚ö†Ô∏è  BUENO - Algunas mejoras recomendadas"
else
  echo "üéØ Estado: ‚ùå REQUIERE ATENCI√ìN - Varios elementos por corregir"
fi

echo ""

# Mostrar observaciones si las hay
if [ ${#OBSERVATIONS[@]} -gt 0 ]; then
  echo "üëÄ Observaciones:"
  for obs in "${OBSERVATIONS[@]}"; do
    echo "   ‚ÑπÔ∏è  $obs"
  done
  echo ""
fi

# Mostrar recomendaciones si las hay
if [ ${#RECOMMENDATIONS[@]} -gt 0 ]; then
  echo "üí° Recomendaciones:"
  for rec in "${RECOMMENDATIONS[@]}"; do
    echo "   üìù $rec"
  done
  echo ""
fi

# Contexto del issue principal si existe
if [ ! -z "$RELATED_ISSUES" ]; then
  MAIN_ISSUE=$(echo $RELATED_ISSUES | cut -d' ' -f1)
  ISSUE_NUM=$(echo $MAIN_ISSUE | sed 's/#//')
  
  if [ -f ".claude/temp/issue-$ISSUE_NUM-info.json" ]; then
    ISSUE_TITLE=$(jq -r '.title' .claude/temp/issue-$ISSUE_NUM-info.json)
    echo "üéØ Contexto del Issue Principal ($MAIN_ISSUE):"
    echo "   \"$ISSUE_TITLE\""
    echo ""
  fi
fi

echo "üîó PR: $(gh pr view $PR_NUMBER --json url --jq '.url')"
echo ""

# Limpieza de archivos temporales
rm -f .claude/temp/issue-*-info.json 2>/dev/null
rm -f .claude/temp/issue-*-context.json 2>/dev/null

# Determinaci√≥n del veredicto final
VERDICTO=""
if [ $PERCENTAGE -ge 70 ] && [ ${#RECOMMENDATIONS[@]} -eq 0 ]; then
  VEREDICTO="‚úÖ APROBADO: PR cumple todos los est√°ndares de calidad"
  
elif [ $PERCENTAGE -ge 50 ]; then
  VEREDICTO="‚ö†Ô∏è  CONDICIONAL: PR requiere ajustes menores antes del review"
  
else
  VEREDICTO="‚ùå RECHAZADO: PR requiere correcciones significativas"
  
fi

echo "$VEREDICTO"
echo ""

# IMPORTANTE: Preguntar interactivamente si agregar comentario
# NO automatizar esta decisi√≥n - siempre preguntar al usuario
echo "üí¨ ¬øDesea agregar este reporte como comentario en el PR? (y/n)"
read -r ADD_COMMENT

if [ "$ADD_COMMENT" = "y" ] || [ "$ADD_COMMENT" = "Y" ]; then
    # Crear comentario con el reporte de validaci√≥n
    VALIDATION_COMMENT="## üìã Reporte de Validaci√≥n Autom√°tica

**Resultado:** $VERDICTO

**üìä Resumen:** $VALIDATIONS_PASSED/$VALIDATIONS_TOTAL validaciones pasaron ($PERCENTAGE%)"
    
    if [ ${#OBSERVATIONS[@]} -gt 0 ]; then
      VALIDATION_COMMENT="$VALIDATION_COMMENT

**üëÄ Observaciones:**"
      for obs in "${OBSERVATIONS[@]}"; do
        VALIDATION_COMMENT="$VALIDATION_COMMENT
- $obs"
      done
    fi
    
    if [ ${#RECOMMENDATIONS[@]} -gt 0 ]; then
      VALIDATION_COMMENT="$VALIDATION_COMMENT

**üí° Recomendaciones:**"
      for rec in "${RECOMMENDATIONS[@]}"; do
        VALIDATION_COMMENT="$VALIDATION_COMMENT
- $rec"
      done
    fi
    
    VALIDATION_COMMENT="$VALIDATION_COMMENT

---
*Validaci√≥n autom√°tica realizada por [/validate-pr](.claude/commands/validate-pr.md)*"
    
    # Agregar comentario al PR
    gh pr comment $PR_NUMBER --body "$VALIDATION_COMMENT"
fi
```

## Caracter√≠sticas

- **An√°lisis de Contexto Completo**: Compara PR con issues relacionados, comentarios y documentaci√≥n
- **Detecci√≥n Autom√°tica**: Usa GraphQL para detectar relaciones PR-Issue que GitHub identifica autom√°ticamente
- **An√°lisis de Comentarios**: Extrae testing reportado, decisiones y requirements de comentarios del issue
- **Validaci√≥n de Proceso**: Enfocado en cumplimiento de est√°ndares y alineaci√≥n con objetivos del proyecto
- **Comentario Autom√°tico**: Opci√≥n de agregar reporte como comentario en el PR para seguimiento
- **Reporte Claro**: Output estructurado con porcentajes y recomendaciones espec√≠ficas
- **Detecci√≥n Inteligente**: Identifica endpoints, testing y requirements adicionales mencionados
- **Escalable**: Base s√≥lida para agregar m√°s validaciones en futuras versiones
- **R√°pido**: Proceso completo en ~30 segundos

## Uso

```bash
/validate-pr 16
```

## Output Ejemplo

```
üìã Analizando Issue #1:
  - T√≠tulo: Desplegar Infraestructura AWS
  - Estado: CLOSED
  - Labels: infrastructure,backend
  - Comentarios: 3
  üìù Analizando comentarios del issue...
     ‚úÖ Testing/validaci√≥n reportado en comentarios
     üîó URLs/endpoints mencionados: https://api.esenciafest.com/health
     üìã Decisiones/cambios importantes documentados en comentarios

üìã REPORTE DE VALIDACI√ìN - PR #16
=================================

üìä Resumen: 4/5 validaciones pasaron (80%)
üéØ Estado: ‚úÖ EXCELENTE - Listo para review

4Ô∏è‚É£ Contexto de Comentarios del Issue:
   ‚úÖ Testing fue reportado en comentarios del issue
   ‚úÖ PR menciona testing/validaci√≥n realizada
   ‚úÖ Decisiones importantes documentadas en comentarios
   üîó Endpoints mencionados en issue: https://api.esenciafest.com/health
   ‚úÖ PR alineado con contexto de comentarios del issue

üéØ Contexto del Issue Principal (#1):
   "Desplegar Infraestructura AWS"

üîó PR: https://github.com/repo/pull/16

‚úÖ VEREDICTO: PR APROBADO - Cumple todos los est√°ndares de calidad
```