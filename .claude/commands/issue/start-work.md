---
description: Iniciar trabajo en un issue creando ramas y configurando el entorno
allowed-tools: [Read, Bash, Glob, TodoWrite]
---

# Start Work Issue

Iniciar trabajo en un issue espec√≠fico: **$ARGUMENTS**

## Proceso:

### 1. Validar Entorno y Prerequisites

```bash
# Validar que existe el plan del issue
ISSUE_PLAN_FILE="$1"
if [ -z "$ISSUE_PLAN_FILE" ]; then
  echo "‚ùå Error: Debes especificar el archivo del plan del issue"
  echo "Uso: /start-work-issue issue-plan-123.md"
  exit 1
fi

PLAN_PATH=".claude/artifact-temp/$ISSUE_PLAN_FILE"
if [ ! -f "$PLAN_PATH" ]; then
  echo "‚ùå Error: Plan del issue no encontrado: $PLAN_PATH"
  echo "‚ùó IMPORTANTE: Los planes se buscan en .claude/artifact-temp/ del proyecto actual"
  echo "Ejecuta primero: /plan-issue [numero]"
  exit 1
fi

echo "‚úÖ Plan encontrado: $PLAN_PATH"

# Extraer n√∫mero del issue del nombre del archivo
ISSUE_NUMBER=$(echo "$ISSUE_PLAN_FILE" | grep -oE "[0-9]+" | head -1)
if [ -z "$ISSUE_NUMBER" ]; then
  echo "‚ùå Error: No se pudo extraer n√∫mero del issue de: $ISSUE_PLAN_FILE"
  exit 1
fi

echo "üéØ Issue detectado: #$ISSUE_NUMBER"
```

### 2. Validar Estado Actual del Workspace

```bash
# Verificar que workspace est√° limpio
if ! git diff --quiet || ! git diff --cached --quiet; then
  echo "‚ùå Error: Workspace tiene cambios uncommitted"
  echo "Haz commit o stash de tus cambios antes de continuar"
  git status --short
  exit 1
fi

# Obtener branch actual y base
CURRENT_BRANCH=$(git branch --show-current)
BASE_BRANCH=$(git symbolic-ref refs/remotes/origin/HEAD | sed 's@^refs/remotes/origin/@@')

echo "üìÇ Branch actual: $CURRENT_BRANCH"
echo "üìÇ Base branch: $BASE_BRANCH"

# Verificar que estamos en base branch o que podemos hacer switch seguro
if [ "$CURRENT_BRANCH" != "$BASE_BRANCH" ]; then
  echo "‚ö†Ô∏è  No est√°s en $BASE_BRANCH. Cambiando autom√°ticamente..."
  git checkout "$BASE_BRANCH" || {
    echo "‚ùå Error: No se pudo cambiar a $BASE_BRANCH"
    exit 1
  }
fi

# Pull latest changes
echo "üîÑ Actualizando $BASE_BRANCH..."
git pull origin "$BASE_BRANCH" || {
  echo "‚ùå Error: No se pudo actualizar $BASE_BRANCH"
  exit 1
}

echo "‚úÖ Workspace validado y actualizado"
```

### 3. Leer y Parsear Estrategia del Plan

```bash
echo "üìã Leyendo estrategia del plan..."

# Crear directorio temporal para variables persistentes
mkdir -p .claude/temp

# Leer el plan completo
PLAN_CONTENT=$(cat "$PLAN_PATH")

# Extraer nombre de rama recomendado del plan
BRANCH_NAME=$(echo "$PLAN_CONTENT" | grep -oE "feature/issue-[0-9]+-[a-zA-Z0-9-]+" | head -1)
if [ -z "$BRANCH_NAME" ]; then
  # Fallback: generar nombre est√°ndar usando alternativa a jq
  if command -v jq >/dev/null 2>&1; then
    ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title --jq '.title' 2>/dev/null)
  else
    ISSUE_TITLE=$(gh issue view "$ISSUE_NUMBER" --json title 2>/dev/null | grep '"title"' | sed 's/.*"title": *"\([^"]*\)".*/\1/')
  fi
  
  if [ ! -z "$ISSUE_TITLE" ]; then
    BRANCH_SUFFIX=$(echo "$ISSUE_TITLE" | tr '[:upper:]' '[:lower:]' | sed 's/[^a-z0-9]/-/g' | sed 's/--*/-/g' | sed 's/^-\|-$//g' | cut -c1-30)
    BRANCH_NAME="feature/issue-$ISSUE_NUMBER-$BRANCH_SUFFIX"
  else
    BRANCH_NAME="feature/issue-$ISSUE_NUMBER"
  fi
fi

echo "üåø Nombre de rama: $BRANCH_NAME"

# Guardar variables en archivo temporal para persistencia
cat > .claude/temp/vars.env << 'EOF'
ISSUE_NUMBER="$ISSUE_NUMBER"
BRANCH_NAME="$BRANCH_NAME"
BASE_BRANCH="$BASE_BRANCH"
PLAN_PATH="$PLAN_PATH"
ISSUE_PLAN_FILE="$ISSUE_PLAN_FILE"
EOF

# Verificar si necesita subramas (solo si el plan lo especifica expl√≠citamente)
NEEDS_SUBBRANCHES=$(echo "$PLAN_CONTENT" | grep -i -c "subrama\|sub-rama\|subbranch\|sub-branch" || echo "0")
CREATE_SUBISSUES=$(echo "$PLAN_CONTENT" | grep -i -c "sub-issue\|subissue\|dividir.*issue\|crear.*issue" || echo "0")

if [ "$NEEDS_SUBBRANCHES" -gt 0 ]; then
  echo "üîÄ Plan requiere subramas - se configurar√°n despu√©s"
fi

if [ "$CREATE_SUBISSUES" -gt 0 ]; then
  echo "üìã Plan requiere sub-issues - se crear√°n despu√©s"
fi

# Verificar si necesita version bump
NEEDS_VERSION_BUMP=$(echo "$PLAN_CONTENT" | grep -i -c "version\|bump\|package\.json" || echo "0")
```

### 4. Validar que la Rama No Existe

```bash
echo "üîç Validando que la rama no existe..."

# Verificar localmente
if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
  echo "‚ùå Error: La rama '$BRANCH_NAME' ya existe localmente"
  echo "Ramas existentes para este issue:"
  git branch --list "*issue-$ISSUE_NUMBER*"
  exit 1
fi

# Verificar remotamente
if git ls-remote --exit-code --heads origin "$BRANCH_NAME" >/dev/null 2>&1; then
  echo "‚ùå Error: La rama '$BRANCH_NAME' ya existe en el remoto"
  exit 1
fi

echo "‚úÖ Rama '$BRANCH_NAME' disponible"
```

### 5. Verificar Estado del Issue en GitHub

```bash
echo "üîç Verificando estado del issue #$ISSUE_NUMBER en GitHub..."

# Obtener estado actual del issue
ISSUE_INFO=$(gh issue view "$ISSUE_NUMBER" --json state,assignees,labels,title 2>/dev/null)
if [ $? -ne 0 ]; then
  echo "‚ùå Error: No se pudo acceder al issue #$ISSUE_NUMBER"
  exit 1
fi

# Extraer informaci√≥n usando alternativa a jq si no est√° disponible
if command -v jq >/dev/null 2>&1; then
  ISSUE_STATE=$(echo "$ISSUE_INFO" | jq -r '.state')
  ISSUE_TITLE=$(echo "$ISSUE_INFO" | jq -r '.title')
  CURRENT_ASSIGNEES=$(echo "$ISSUE_INFO" | jq -r '.assignees[].login' | tr '\n' ',' | sed 's/,$//')
else
  ISSUE_STATE=$(echo "$ISSUE_INFO" | grep '"state"' | sed 's/.*"state": *"\([^"]*\)".*/\1/')
  ISSUE_TITLE=$(echo "$ISSUE_INFO" | grep '"title"' | sed 's/.*"title": *"\([^"]*\)".*/\1/')
  CURRENT_ASSIGNEES=$(echo "$ISSUE_INFO" | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/' | tr '\n' ',' | sed 's/,$//')
fi

echo "üìã Issue: $ISSUE_TITLE"
echo "üìä Estado actual: $ISSUE_STATE"

if [ "$ISSUE_STATE" != "open" ]; then
  echo "‚ö†Ô∏è  Issue #$ISSUE_NUMBER no est√° abierto (estado: $ISSUE_STATE)"
  read -p "¬øContinuar de todas formas? (y/N): " CONTINUE
  if [ "$CONTINUE" != "y" ] && [ "$CONTINUE" != "Y" ]; then
    echo "‚ùå Operaci√≥n cancelada"
    exit 1
  fi
fi

# Verificar si ya est√° asignado a alguien m√°s
if [ ! -z "$CURRENT_ASSIGNEES" ]; then
  if command -v jq >/dev/null 2>&1; then
    CURRENT_USER=$(gh api user --jq '.login')
  else
    CURRENT_USER=$(gh api user | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/')
  fi
  
  if [ "$CURRENT_ASSIGNEES" != "$CURRENT_USER" ]; then
    echo "‚ö†Ô∏è  Issue ya est√° asignado a: $CURRENT_ASSIGNEES"
    read -p "¬øContinuar y reasignar? (y/N): " REASSIGN
    if [ "$REASSIGN" != "y" ] && [ "$REASSIGN" != "Y" ]; then
      echo "‚ùå Operaci√≥n cancelada"
      exit 1
    fi
  fi
fi

echo "‚úÖ Issue validado"
```

### 6. Crear TodoWrite para Tracking

```bash
echo "üìù Creando todo list para tracking..."
```

**Crear TodoWrite:**
- [ ] Crear rama principal para el issue
- [ ] Configurar tracking issue-rama
- [ ] Actualizar versi√≥n si es necesario
- [ ] Asignar issue y marcar como "In Progress"
- [ ] Crear sub-issues si el plan lo especifica
- [ ] Configurar subramas si el plan lo requiere

### 7. Crear Rama Principal (Con Linking Autom√°tico)

```bash
echo "üåø Creando rama: $BRANCH_NAME"

# Estrategia 1: Intentar gh issue develop (rama vinculada autom√°ticamente)
echo "üîó Intentando crear rama vinculada autom√°ticamente..."
LINKED_BRANCH_CREATED=false

if gh issue develop "$ISSUE_NUMBER" --name "$BRANCH_NAME" --checkout 2>/dev/null; then
  echo "‚úÖ Rama '$BRANCH_NAME' creada y vinculada autom√°ticamente con gh issue develop"
  LINKED_BRANCH_CREATED=true
else
  echo "‚ö†Ô∏è  gh issue develop fall√≥, usando m√©todo tradicional..."
  
  # Estrategia 2: Fallback con git checkout -b (m√©todo tradicional)
  git checkout -b "$BRANCH_NAME" || {
    echo "‚ùå Error: No se pudo crear la rama $BRANCH_NAME"
    exit 1
  }
  
  echo "‚úÖ Rama '$BRANCH_NAME' creada con m√©todo tradicional"
fi

# Verificar que estamos en la rama correcta
CURRENT_BRANCH=$(git branch --show-current)
if [ "$CURRENT_BRANCH" != "$BRANCH_NAME" ]; then
  echo "‚ùå Error: No se pudo cambiar a la rama $BRANCH_NAME"
  exit 1
fi

echo "‚úÖ Rama '$BRANCH_NAME' activada correctamente"
```

### 8. Configurar Tracking y Verificar Linking Issue-Rama

```bash
echo "üîó Configurando tracking issue-rama..."

# Configurar upstream tracking (push de la rama si no fue creada con gh issue develop)
if [ "$LINKED_BRANCH_CREATED" = false ]; then
  git push -u origin "$BRANCH_NAME" || {
    echo "‚ùå Error: No se pudo hacer push inicial de la rama"
    exit 1
  }
  echo "‚úÖ Rama '$BRANCH_NAME' pushed y configurada para tracking"
else
  echo "‚úÖ Rama ya configurada autom√°ticamente con gh issue develop"
fi

# Verificar estado del linking con GitHub API
echo "üîç Verificando linking autom√°tico issue-rama..."
sleep 2  # Dar tiempo para que GitHub sincronice

# Obtener owner y repo din√°micamente usando alternativa a jq
if command -v jq >/dev/null 2>&1; then
  REPO_OWNER=$(gh repo view --json owner --jq '.owner.login')
  REPO_NAME=$(gh repo view --json name --jq '.name')
else
  REPO_OWNER=$(gh repo view --json owner | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/')
  REPO_NAME=$(gh repo view --json name | grep '"name"' | sed 's/.*"name": *"\([^"]*\)".*/\1/')
fi

LINKED_BRANCHES=$(gh api graphql -f query='query { repository(owner: "'$REPO_OWNER'", name: "'$REPO_NAME'") { issue(number: '$ISSUE_NUMBER') { linkedBranches(first: 10) { nodes { ref { name } } } } } }' --jq '.data.repository.issue.linkedBranches.nodes[].ref.name' 2>/dev/null || echo "")

BRANCH_IS_LINKED=false
if echo "$LINKED_BRANCHES" | grep -q "^$BRANCH_NAME$"; then
  echo "‚úÖ Rama '$BRANCH_NAME' est√° vinculada correctamente al issue #$ISSUE_NUMBER"
  BRANCH_IS_LINKED=true
else
  echo "‚ö†Ô∏è  Rama '$BRANCH_NAME' NO est√° vinculada autom√°ticamente al issue #$ISSUE_NUMBER"
  echo "üí° Se vincular√° autom√°ticamente al crear el PR"
fi

# Crear metadata para linking usando formato m√°s robusto
mkdir -p .claude/temp

# Crear JSON de forma m√°s segura (evita problemas con heredoc)
echo "{" > .claude/temp/current-work.json
echo "  \"issue_number\": \"$ISSUE_NUMBER\"," >> .claude/temp/current-work.json
echo "  \"issue_title\": \"$ISSUE_TITLE\"," >> .claude/temp/current-work.json
echo "  \"branch_name\": \"$BRANCH_NAME\"," >> .claude/temp/current-work.json
echo "  \"base_branch\": \"$BASE_BRANCH\"," >> .claude/temp/current-work.json
echo "  \"started_at\": \"$(date -Iseconds)\"," >> .claude/temp/current-work.json
echo "  \"plan_file\": \"$ISSUE_PLAN_FILE\"," >> .claude/temp/current-work.json
echo "  \"needs_subbranches\": $NEEDS_SUBBRANCHES," >> .claude/temp/current-work.json
echo "  \"create_subissues\": $CREATE_SUBISSUES," >> .claude/temp/current-work.json
echo "  \"needs_version_bump\": $NEEDS_VERSION_BUMP," >> .claude/temp/current-work.json
echo "  \"linked_branch_created\": $LINKED_BRANCH_CREATED," >> .claude/temp/current-work.json
echo "  \"branch_is_linked\": $BRANCH_IS_LINKED" >> .claude/temp/current-work.json
echo "}" >> .claude/temp/current-work.json

echo "‚úÖ Metadata de trabajo guardada en .claude/temp/current-work.json"
```

### 9. Version Bump (Solo si el Plan lo Especifica)

```bash
if [ "$NEEDS_VERSION_BUMP" -gt 0 ]; then
  echo "üì¶ Actualizando versi√≥n seg√∫n plan..."
  
  # Buscar package.json en el proyecto
  if [ -f "package.json" ]; then
    # Obtener versi√≥n actual usando alternativa a jq
    if command -v jq >/dev/null 2>&1; then
      CURRENT_VERSION=$(jq -r '.version' package.json)
    else
      CURRENT_VERSION=$(grep '"version"' package.json | sed 's/.*"version": *"\([^"]*\)".*/\1/')
    fi
    echo "üì¶ Versi√≥n actual: $CURRENT_VERSION"
    
    # Hacer bump incremental para desarrollo (patch)
    npm version patch --no-git-tag-version || {
      echo "‚ö†Ô∏è  No se pudo hacer version bump autom√°tico"
    }
    
    # Obtener nueva versi√≥n usando alternativa a jq
    if command -v jq >/dev/null 2>&1; then
      NEW_VERSION=$(jq -r '.version' package.json)
    else
      NEW_VERSION=$(grep '"version"' package.json | sed 's/.*"version": *"\([^"]*\)".*/\1/')
    fi
    echo "üì¶ Nueva versi√≥n: $NEW_VERSION"
    
    # Commit del version bump
    git add package.json package-lock.json 2>/dev/null
    git commit -m "chore: bump version to $NEW_VERSION for issue #$ISSUE_NUMBER development" || true
    
    echo "‚úÖ Version bump completado"
  else
    echo "‚ö†Ô∏è  package.json no encontrado - saltando version bump"
  fi
else
  echo "üì¶ Plan no requiere version bump - saltando"
fi
```

### 10. Asignar Issue y Marcar como "In Progress"

```bash
echo "üë§ Asignando issue y actualizando estado..."

# Obtener usuario actual usando alternativa a jq
if command -v jq >/dev/null 2>&1; then
  CURRENT_USER=$(gh api user --jq '.login')
else
  CURRENT_USER=$(gh api user | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/')
fi

# Asignar issue al usuario actual (usar flag correcto)
gh issue edit "$ISSUE_NUMBER" --add-assignee "@me" || {
  echo "‚ö†Ô∏è  No se pudo asignar el issue autom√°ticamente"
}

# ===== NUEVO: CAMBIAR STATUS EN PROJECT A "IN PROGRESS" =====
echo "üìä Cambiando status del project a 'In Progress'..."

# Obtener informaci√≥n del repositorio
if command -v jq >/dev/null 2>&1; then
  REPO_OWNER=$(gh repo view --json owner --jq '.owner.login')
  REPO_NAME=$(gh repo view --json name --jq '.name')
else
  REPO_OWNER=$(gh repo view --json owner | grep '"login"' | sed 's/.*"login": *"\([^"]*\)".*/\1/')
  REPO_NAME=$(gh repo view --json name | grep '"name"' | sed 's/.*"name": *"\([^"]*\)".*/\1/')
fi

# Buscar projects del owner
echo "üîç Buscando projects disponibles..."
PROJECT_LIST=$(gh project list --owner "$REPO_OWNER" --format json 2>/dev/null)

if [ ! -z "$PROJECT_LIST" ]; then
  # Buscar project "Esencia Fest 2025" o usar el primer project activo
  if command -v jq >/dev/null 2>&1; then
    PROJECT_NUMBER=$(echo "$PROJECT_LIST" | jq -r '.projects[] | select(.title | test("Esencia Fest|esencia|fest"; "i")) | .number' | head -1)
    if [ -z "$PROJECT_NUMBER" ]; then
      PROJECT_NUMBER=$(echo "$PROJECT_LIST" | jq -r '.projects[0].number')
    fi
  else
    PROJECT_NUMBER=$(echo "$PROJECT_LIST" | grep -i -A5 -B5 "esencia\|fest" | grep '"number"' | head -1 | sed 's/.*"number": *\([0-9]*\).*/\1/')
    if [ -z "$PROJECT_NUMBER" ]; then
      PROJECT_NUMBER=$(echo "$PROJECT_LIST" | grep '"number"' | head -1 | sed 's/.*"number": *\([0-9]*\).*/\1/')
    fi
  fi
  
  if [ ! -z "$PROJECT_NUMBER" ]; then
    echo "üìã Project encontrado: #$PROJECT_NUMBER"
    
    # Obtener informaci√≥n del project y campos
    PROJECT_FIELDS=$(gh api graphql -f query='
    query {
      organization(login: "'$REPO_OWNER'") {
        projectV2(number: '$PROJECT_NUMBER') {
          id
          fields(first: 20) {
            nodes {
              ... on ProjectV2SingleSelectField {
                id
                name
                options {
                  id
                  name
                }
              }
            }
          }
        }
      }
    }' 2>/dev/null)
    
    if [ ! -z "$PROJECT_FIELDS" ]; then
      # Extraer ID del project y del campo Status
      if command -v jq >/dev/null 2>&1; then
        PROJECT_ID=$(echo "$PROJECT_FIELDS" | jq -r '.data.organization.projectV2.id')
        STATUS_FIELD_ID=$(echo "$PROJECT_FIELDS" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Status") | .id')
        IN_PROGRESS_OPTION_ID=$(echo "$PROJECT_FIELDS" | jq -r '.data.organization.projectV2.fields.nodes[] | select(.name == "Status") | .options[] | select(.name == "In Progress") | .id')
      else
        PROJECT_ID=$(echo "$PROJECT_FIELDS" | grep '"id"' | head -1 | sed 's/.*"id": *"\([^"]*\)".*/\1/')
        STATUS_FIELD_ID=$(echo "$PROJECT_FIELDS" | grep -A20 '"name": *"Status"' | grep '"id"' | head -1 | sed 's/.*"id": *"\([^"]*\)".*/\1/')
        IN_PROGRESS_OPTION_ID=$(echo "$PROJECT_FIELDS" | grep -A50 '"name": *"Status"' | grep -A5 '"name": *"In Progress"' | grep '"id"' | head -1 | sed 's/.*"id": *"\([^"]*\)".*/\1/')
      fi
      
      if [ ! -z "$PROJECT_ID" ] && [ ! -z "$STATUS_FIELD_ID" ] && [ ! -z "$IN_PROGRESS_OPTION_ID" ]; then
        echo "üîß IDs encontrados - Project: $PROJECT_ID, Status Field: $STATUS_FIELD_ID, In Progress: $IN_PROGRESS_OPTION_ID"
        
        # Buscar el item del issue en el project
        PROJECT_ITEMS=$(gh api graphql -f query='
        query {
          organization(login: "'$REPO_OWNER'") {
            projectV2(number: '$PROJECT_NUMBER') {
              items(first: 100) {
                nodes {
                  id
                  content {
                    ... on Issue {
                      number
                    }
                  }
                }
              }
            }
          }
        }' 2>/dev/null)
        
        if [ ! -z "$PROJECT_ITEMS" ]; then
          if command -v jq >/dev/null 2>&1; then
            ITEM_ID=$(echo "$PROJECT_ITEMS" | jq -r '.data.organization.projectV2.items.nodes[] | select(.content.number == '$ISSUE_NUMBER') | .id')
          else
            # Buscar el item ID para el issue espec√≠fico (m√°s complejo sin jq)
            ITEM_ID=$(echo "$PROJECT_ITEMS" | grep -B3 -A1 '"number": *'$ISSUE_NUMBER',' | grep '"id"' | head -1 | sed 's/.*"id": *"\([^"]*\)".*/\1/')
          fi
          
          if [ ! -z "$ITEM_ID" ]; then
            echo "üéØ Item encontrado: $ITEM_ID"
            
            # Cambiar status a "In Progress"
            RESULT=$(gh project item-edit \
              --project-id "$PROJECT_ID" \
              --id "$ITEM_ID" \
              --field-id "$STATUS_FIELD_ID" \
              --single-select-option-id "$IN_PROGRESS_OPTION_ID" 2>/dev/null)
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Status cambiado a 'In Progress' en project #$PROJECT_NUMBER"
              
              # Verificar el cambio
              sleep 1
              VERIFICATION=$(gh issue view "$ISSUE_NUMBER" --json projectItems 2>/dev/null)
              if echo "$VERIFICATION" | grep -q "In Progress"; then
                echo "‚úÖ Verificaci√≥n: Status actualizado correctamente"
              else
                echo "‚ö†Ô∏è  Verificaci√≥n: Status podr√≠a no haberse actualizado"
              fi
            else
              echo "‚ö†Ô∏è  No se pudo cambiar el status en el project"
            fi
          else
            echo "‚ö†Ô∏è  No se encontr√≥ el issue #$ISSUE_NUMBER en el project #$PROJECT_NUMBER"
          fi
        else
          echo "‚ö†Ô∏è  No se pudieron obtener los items del project"
        fi
      else
        echo "‚ö†Ô∏è  No se encontraron los IDs necesarios para cambiar el status"
        echo "    Project ID: $PROJECT_ID"
        echo "    Status Field ID: $STATUS_FIELD_ID" 
        echo "    In Progress Option ID: $IN_PROGRESS_OPTION_ID"
      fi
    else
      echo "‚ö†Ô∏è  No se pudo obtener informaci√≥n de campos del project"
    fi
  else
    echo "‚ö†Ô∏è  No se encontr√≥ un project v√°lido"
  fi
else
  echo "‚ö†Ô∏è  No se encontraron projects para el owner $REPO_OWNER"
fi

# ===== FIN NUEVO: CAMBIAR STATUS EN PROJECT =====

# Verificar qu√© labels existen antes de intentar agregar
echo "üîç Verificando labels disponibles..."
AVAILABLE_LABELS=$(gh label list --limit 100 | grep -E '(progress|work|dev)' | head -5)
if [ ! -z "$AVAILABLE_LABELS" ]; then
  echo "üìã Labels relacionados encontrados:"
  echo "$AVAILABLE_LABELS"
fi

# Intentar agregar label "in-progress" o similar
if gh label list | grep -q "in-progress"; then
  gh issue edit "$ISSUE_NUMBER" --add-label "in-progress"
  echo "‚úÖ Label 'in-progress' agregado"
elif gh label list | grep -q "work"; then
  gh issue edit "$ISSUE_NUMBER" --add-label "work"
  echo "‚úÖ Label 'work' agregado como alternativa"
else
  echo "‚ö†Ô∏è  No se encontraron labels apropiados para marcar como 'en progreso'"
fi

# Comentar en el issue con informaci√≥n de la rama
gh issue comment "$ISSUE_NUMBER" --body "üöÄ **Trabajo iniciado**

- **Rama**: \`$BRANCH_NAME\`
- **Iniciado por**: @$CURRENT_USER
- **Plan**: $ISSUE_PLAN_FILE

El desarrollo est√° en progreso. Los commits se pueden seguir en la rama [\`$BRANCH_NAME\`](../compare/$BASE_BRANCH...$BRANCH_NAME)." || {
  echo "‚ö†Ô∏è  No se pudo comentar en el issue"
}

echo "‚úÖ Issue #$ISSUE_NUMBER asignado y marcado como In Progress (labels + project status)"
```

### 11. Crear Sub-issues (Solo si el Plan lo Especifica)

```bash
if [ "$CREATE_SUBISSUES" -gt 0 ]; then
  echo "üìã Creando sub-issues seg√∫n plan..."
  
  # Extraer sub-issues del plan (buscar patrones espec√≠ficos)
  SUBISSUE_TITLES=$(echo "$PLAN_CONTENT" | grep -E "^\s*-\s.*\b(issue|tarea|task)\b" | sed 's/^\s*-\s*//' | head -5)
  
  if [ ! -z "$SUBISSUE_TITLES" ]; then
    SUBISSUE_COUNT=0
    echo "$SUBISSUE_TITLES" | while IFS= read -r SUBISSUE_TITLE; do
      if [ ! -z "$SUBISSUE_TITLE" ]; then
        SUBISSUE_COUNT=$((SUBISSUE_COUNT + 1))
        echo "  üìã Creando sub-issue: $SUBISSUE_TITLE"
        
        SUBISSUE_BODY="Sub-issue derivado de #$ISSUE_NUMBER

**Contexto**: Este es un sub-issue creado autom√°ticamente para organizar el trabajo del issue principal.

**Issue padre**: #$ISSUE_NUMBER  
**Rama padre**: \`$BRANCH_NAME\`

**Descripci√≥n**: $SUBISSUE_TITLE"

        # Crear el sub-issue
        NEW_SUBISSUE=$(gh issue create --title "[$ISSUE_NUMBER] $SUBISSUE_TITLE" --body "$SUBISSUE_BODY" --label "sub-issue" 2>/dev/null)
        
        if [ $? -eq 0 ]; then
          SUBISSUE_NUMBER=$(echo "$NEW_SUBISSUE" | grep -oE "[0-9]+$")
          echo "    ‚úÖ Sub-issue #$SUBISSUE_NUMBER creado"
          
          # Comentar en el issue padre
          gh issue comment "$ISSUE_NUMBER" --body "üìã Sub-issue creado: #$SUBISSUE_NUMBER - $SUBISSUE_TITLE" 2>/dev/null
        else
          echo "    ‚ö†Ô∏è  No se pudo crear sub-issue: $SUBISSUE_TITLE"
        fi
      fi
    done
    
    echo "‚úÖ Sub-issues procesados"
  else
    echo "‚ö†Ô∏è  No se encontraron sub-issues espec√≠ficos en el plan"
  fi
else
  echo "üìã Plan no requiere sub-issues - saltando"
fi
```

### 12. Configurar Subramas (Solo si el Plan lo Requiere)

```bash
if [ "$NEEDS_SUBBRANCHES" -gt 0 ]; then
  echo "üîÄ Configurando subramas seg√∫n plan..."
  
  # Extraer nombres de subramas del plan
  SUBBRANCH_NAMES=$(echo "$PLAN_CONTENT" | grep -oE "feature/[a-zA-Z0-9-]*" | grep -v "$BRANCH_NAME" | head -3)
  
  if [ ! -z "$SUBBRANCH_NAMES" ]; then
    echo "$SUBBRANCH_NAMES" | while IFS= read -r SUBBRANCH_NAME; do
      if [ ! -z "$SUBBRANCH_NAME" ]; then
        echo "  üîÄ Preparando subbranch: $SUBBRANCH_NAME"
        
        # Verificar que no existe
        if ! git show-ref --verify --quiet "refs/heads/$SUBBRANCH_NAME"; then
          # Crear rama pero no cambiar a ella
          git branch "$SUBBRANCH_NAME" || {
            echo "    ‚ö†Ô∏è  No se pudo crear subbranch: $SUBBRANCH_NAME"
            continue
          }
          
          # Push subbranch
          git push -u origin "$SUBBRANCH_NAME" || {
            echo "    ‚ö†Ô∏è  No se pudo hacer push de subbranch: $SUBBRANCH_NAME"
          }
          
          echo "    ‚úÖ Subbranch '$SUBBRANCH_NAME' creada"
        else
          echo "    ‚ö†Ô∏è  Subbranch '$SUBBRANCH_NAME' ya existe"
        fi
      fi
    done
    
    # Volver a la rama principal
    git checkout "$BRANCH_NAME"
    
    echo "‚úÖ Subramas configuradas"
  else
    echo "‚ö†Ô∏è  No se encontraron subramas espec√≠ficas en el plan"
  fi
else
  echo "üîÄ Plan no requiere subramas - saltando"
fi
```

### 13. Output Final y Preparaci√≥n

```bash
echo ""
echo "üéâ WORK INICIADO EXITOSAMENTE"
echo ""
echo "üìä Resumen:"
echo "- Issue: #$ISSUE_NUMBER - $ISSUE_TITLE"
echo "- Rama activa: $BRANCH_NAME"
echo "- Base branch: $BASE_BRANCH"
echo "- Estado: In Progress"
echo "- Asignado a: $CURRENT_USER"

# Verificar y reportar status del project
PROJECT_STATUS_CHECK=$(gh issue view "$ISSUE_NUMBER" --json projectItems 2>/dev/null)
if echo "$PROJECT_STATUS_CHECK" | grep -q "In Progress"; then
  echo "- Project Status: ‚úÖ In Progress"
else
  echo "- Project Status: ‚ö†Ô∏è  Verificar manualmente"
fi

# Reporte de linking
if [ "$LINKED_BRANCH_CREATED" = true ]; then
  echo "- Linking: ‚úÖ Rama creada con gh issue develop"
elif [ "$BRANCH_IS_LINKED" = true ]; then
  echo "- Linking: ‚úÖ Rama vinculada autom√°ticamente"
else
  echo "- Linking: ‚ö†Ô∏è  Vinculaci√≥n manual necesaria (se har√° autom√°ticamente en PR)"
fi

if [ "$NEEDS_VERSION_BUMP" -gt 0 ]; then
  if command -v jq >/dev/null 2>&1; then
    echo "- Versi√≥n: $(jq -r '.version' package.json 2>/dev/null || echo 'N/A')"
  else
    VERSION=$(grep '"version"' package.json 2>/dev/null | sed 's/.*"version": *"\([^"]*\)".*/\1/' || echo 'N/A')
    echo "- Versi√≥n: $VERSION"
  fi
fi
if [ "$CREATE_SUBISSUES" -gt 0 ]; then
  echo "- Sub-issues: Creados seg√∫n plan"
fi
if [ "$NEEDS_SUBBRANCHES" -gt 0 ]; then
  echo "- Subramas: Configuradas seg√∫n plan"
fi
echo ""
echo "üîÑ Siguiente en el flujo:"
echo "  1. ‚úÖ Rama y tracking configurados"
echo "  2. üî® [T√ö] Implementar la soluci√≥n"
echo "  3. üì§ /submit-work-issue (cuando termines)"
echo "  4. ‚úÖ /validate-pr (antes del merge)"
echo ""
echo "üìÇ Workspace listo para desarrollo en: $BRANCH_NAME"
echo "üìã Metadata guardada en: .claude/temp/current-work.json"
echo ""

# Marcar todo como completado en TodoWrite
echo "‚úÖ Todas las validaciones y configuraciones completadas"
```

## Caracter√≠sticas

- **Validaci√≥n exhaustiva**: Verifica workspace, plan, ramas existentes y estado del issue
- **Creaci√≥n inteligente**: Solo crea subramas y sub-issues si el plan lo especifica expl√≠citamente
- **Linking robusto**: Intenta `gh issue develop` primero, fallback a m√©todo tradicional + verificaci√≥n API
- **Verificaci√≥n real**: Confirma con GraphQL API si la rama qued√≥ vinculada al issue
- **Estado sincronizado completo**: Asigna, marca como "In Progress" en labels Y project status, comenta en GitHub
- **Project Management automatizado**: Detecta autom√°ticamente el project correcto y cambia status de "Backlog" a "In Progress"
- **Transparencia total**: Reporta claramente el estado del linking y project status (exitoso/manual/verificar)
- **Seguridad**: M√∫ltiples validaciones antes de cualquier operaci√≥n destructiva
- **Tracking completo**: Metadata para que submit-work-issue funcione correctamente
- **Suporte a planes complejos**: Maneja sub-issues y subramas cuando es necesario
- **Fallback inteligente**: Si no encuentra el project "Esencia Fest", usa el primer project disponible
- **Verificaci√≥n post-cambio**: Confirma que el status del project se actualiz√≥ correctamente

## Flujo de Integraci√≥n

```
/plan-issue 123 ‚Üí /start-work-issue issue-plan-123.md ‚Üí [IMPLEMENTACI√ìN] ‚Üí /submit-work-issue ‚Üí /validate-pr
```

## Validaciones Cr√≠ticas Implementadas

- ‚úÖ **Plan existe y es v√°lido**
- ‚úÖ **Workspace limpio** (no cambios uncommitted)
- ‚úÖ **Rama no existe** (local ni remoto)
- ‚úÖ **Issue accesible** en GitHub
- ‚úÖ **Base branch actualizado**
- ‚úÖ **Sub-items condicionales** (solo si plan los especifica)
- ‚úÖ **Linking issue-rama** correcto
- ‚úÖ **Estado GitHub** sincronizado

**IMPORTANTE**: Este comando prepara completamente el entorno para desarrollo y configura el tracking necesario para el resto del flujo automatizado.